// RUN: cir-opt %s -cir-flatten-cfg -o - | FileCheck %s

!s32i = !cir.int<s, 32>

module {

  cir.func @testFor(%arg0 : !cir.bool) {
    cir.for : cond {
      cir.condition(%arg0)
    } body {
      cir.yield
    } step {
      cir.yield
    }
    cir.return
  }
// CHECK:  cir.func @testFor(%arg0: !cir.bool) {
// CHECK:    cir.br ^bb1
// CHECK:  ^bb1:  // 2 preds: ^bb0, ^bb3
// CHECK:    cir.brcond %arg0 ^bb2, ^bb4
// CHECK:  ^bb2:  // pred: ^bb1
// CHECK:    cir.br ^bb3
// CHECK:  ^bb3:  // pred: ^bb2
// CHECK:    cir.br ^bb1
// CHECK:  ^bb4:  // pred: ^bb1
// CHECK:    cir.return
// CHECK:  }

  // Test while cir.loop operation lowering.
  cir.func @testWhile(%arg0 : !cir.bool) {
    cir.while {
      cir.condition(%arg0)
    } do {
      cir.yield
    }
    cir.return
  }
// CHECK:  cir.func @testWhile(%arg0: !cir.bool) {
// CHECK:    cir.br ^bb1
// CHECK:  ^bb1:  // 2 preds: ^bb0, ^bb2
// CHECK:    cir.brcond %arg0 ^bb2, ^bb3
// CHECK:  ^bb2:  // pred: ^bb1
// CHECK:    cir.br ^bb1
// CHECK:  ^bb3:  // pred: ^bb1
// CHECK:    cir.return
// CHECK:  }

  // Test do-while cir.loop operation lowering.
  cir.func @testDoWhile(%arg0 : !cir.bool) {
    cir.do {
      cir.yield
    } while {
      cir.condition(%arg0)
    }
    cir.return
  }
// CHECK:  cir.func @testDoWhile(%arg0: !cir.bool) {
// CHECK:    cir.br ^bb2
// CHECK:  ^bb1:  // pred: ^bb2
// CHECK:    cir.brcond %arg0 ^bb2, ^bb3
// CHECK:  ^bb2:  // 2 preds: ^bb0, ^bb1
// CHECK:    cir.br ^bb1
// CHECK:  ^bb3:  // pred: ^bb1
// CHECK:    cir.return
// CHECK:  }

  // test corner case 
  // while (1) {
  //     break;
  // }
  cir.func @testWhileWithBreakTerminatedBody(%arg0 : !cir.bool) {
    cir.while {
      cir.condition(%arg0)
    } do {
      cir.break
    }
    cir.return
  }
// CHECK:  cir.func @testWhileWithBreakTerminatedBody(%arg0: !cir.bool) {
// CHECK:    cir.br ^bb1
// CHECK:  ^bb1:  // pred: ^bb0
// CHECK:    cir.brcond %arg0 ^bb2, ^bb3
// CHECK:  ^bb2:  // pred: ^bb1
// CHECK:    cir.br ^bb3
// CHECK:  ^bb3:  // 2 preds: ^bb1, ^bb2
// CHECK:    cir.return
// CHECK:  }

  // test C only corner case - no fails during the lowering
  // for (;;) {
  //     break;
  // }
  cir.func @forWithBreakTerminatedScopeInBody(%arg0 : !cir.bool) {
      cir.for : cond {
        cir.condition(%arg0)
      } body {
        cir.scope { // FIXME(cir): Redundant scope emitted during C codegen.
          cir.break
        }
        cir.yield
      } step {
        cir.yield
      }
    cir.return
  }
// CHECK:  cir.func @forWithBreakTerminatedScopeInBody(%arg0: !cir.bool) {
// CHECK:    cir.br ^bb1
// CHECK:  ^bb1:  // 2 preds: ^bb0, ^bb5
// CHECK:    cir.brcond %arg0 ^bb2, ^bb6
// CHECK:  ^bb2:  // pred: ^bb1
// CHECK:    cir.br ^bb3
// CHECK:  ^bb3:  // pred: ^bb2
// CHECK:    cir.br ^bb6
// CHECK:  ^bb4:  // no predecessors
// CHECK:    cir.br ^bb5
// CHECK:  ^bb5:  // pred: ^bb4
// CHECK:    cir.br ^bb1
// CHECK:  ^bb6:  // 2 preds: ^bb1, ^bb3
// CHECK:    cir.return
// CHECK:  }

}  