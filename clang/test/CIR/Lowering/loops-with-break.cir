// RUN: cir-opt %s -cir-to-llvm -o %t.mlir
// RUN: FileCheck --input-file=%t.mlir %s -check-prefix=MLIR

!s32i = !cir.int<s, 32>
module {
  cir.func @testFor() {
    cir.scope {
      %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
      %1 = cir.const(#cir.int<1> : !s32i) : !s32i
      cir.store %1, %0 : !s32i, cir.ptr <!s32i>
      cir.loop for(cond : {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.const(#cir.int<10> : !s32i) : !s32i
        %4 = cir.cmp(lt, %2, %3) : !s32i, !s32i
        %5 = cir.cast(int_to_bool, %4 : !s32i), !cir.bool
        cir.brcond %5 ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        cir.yield continue
      ^bb2:  // pred: ^bb0
        cir.yield
      }, step : {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.unary(inc, %2) : !s32i, !s32i
        cir.store %3, %0 : !s32i, cir.ptr <!s32i>
        cir.yield
      }) {
        cir.scope {
          cir.scope {
            %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
            %3 = cir.const(#cir.int<5> : !s32i) : !s32i
            %4 = cir.cmp(eq, %2, %3) : !s32i, !s32i
            %5 = cir.cast(int_to_bool, %4 : !s32i), !cir.bool
            cir.if %5 {
              cir.yield break
            }
          }
        }
        cir.yield
      }
    }
    cir.return
  }

// MLIR:          llvm.func @testFor()
// MLIR-NEXT:        llvm.br ^bb1
// MLIR-NEXT:      ^bb1:  // pred: ^bb0
// MLIR-NEXT:        %0 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:        %1 = llvm.alloca %0 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr<i32>
// MLIR-NEXT:        %2 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        llvm.store %2, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb2
// ============= Condition block =============
// MLIR-NEXT:      ^bb2:  // 2 preds: ^bb1, ^bb12
// MLIR-NEXT:        %3 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %4 = llvm.mlir.constant(10 : i32) : i32
// MLIR-NEXT:        %5 = llvm.icmp "slt" %3, %4 : i32
// MLIR-NEXT:        %6 = llvm.zext %5 : i1 to i32
// MLIR-NEXT:        %7 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %8 = llvm.icmp "ne" %6, %7 : i32
// MLIR-NEXT:        %9 = llvm.zext %8 : i1 to i8
// MLIR-NEXT:        %10 = llvm.trunc %9 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %10, ^bb3, ^bb4
// MLIR-NEXT:      ^bb3:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb5
// MLIR-NEXT:      ^bb4:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb13
// MLIR-NEXT:      ^bb5:  // pred: ^bb3
// MLIR-NEXT:        llvm.br ^bb6
// MLIR-NEXT:      ^bb6:  // pred: ^bb5
// MLIR-NEXT:        llvm.br ^bb7
// ============= Block with break =============
// MLIR-NEXT:      ^bb7:  // pred: ^bb6
// MLIR-NEXT:        %11 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %12 = llvm.mlir.constant(5 : i32) : i32
// MLIR-NEXT:        %13 = llvm.icmp "eq" %11, %12 : i32
// MLIR-NEXT:        %14 = llvm.zext %13 : i1 to i32
// MLIR-NEXT:        %15 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %16 = llvm.icmp "ne" %14, %15 : i32
// MLIR-NEXT:        %17 = llvm.zext %16 : i1 to i8
// MLIR-NEXT:        %18 = llvm.trunc %17 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %18, ^bb8, ^bb9
// MLIR-NEXT:      ^bb8:  // pred: ^bb7
// MLIR-NEXT:        llvm.br ^bb13
// MLIR-NEXT:      ^bb9:  // pred: ^bb7
// MLIR-NEXT:        llvm.br ^bb10
// MLIR-NEXT:      ^bb10:  // pred: ^bb9
// MLIR-NEXT:        llvm.br ^bb11
// MLIR-NEXT:      ^bb11:  // pred: ^bb10
// MLIR-NEXT:        llvm.br ^bb12
// ============= Body block =============
// MLIR-NEXT:      ^bb12:  // pred: ^bb11
// MLIR-NEXT:        %19 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %20 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        %21 = llvm.add %19, %20  : i32
// MLIR-NEXT:        llvm.store %21, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb2
// ============= Exit block =============
// MLIR-NEXT:      ^bb13:  // 2 preds: ^bb4, ^bb8
// MLIR-NEXT:        llvm.br ^bb14
// MLIR-NEXT:      ^bb14:  // pred: ^bb13
// MLIR-NEXT:        llvm.return
// MLIR-NEXT:      }

  cir.func @testForNested() {
    cir.scope {
      %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
      %1 = cir.const(#cir.int<1> : !s32i) : !s32i
      cir.store %1, %0 : !s32i, cir.ptr <!s32i>
      cir.loop for(cond : {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.const(#cir.int<10> : !s32i) : !s32i
        %4 = cir.cmp(lt, %2, %3) : !s32i, !s32i
        %5 = cir.cast(int_to_bool, %4 : !s32i), !cir.bool
        cir.brcond %5 ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        cir.yield continue
      ^bb2:  // pred: ^bb0
        cir.yield
      }, step : {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.unary(inc, %2) : !s32i, !s32i
        cir.store %3, %0 : !s32i, cir.ptr <!s32i>
        cir.yield
      }) {
        cir.scope {
          cir.scope {
            %2 = cir.alloca !s32i, cir.ptr <!s32i>, ["j", init] {alignment = 4 : i64}
            %3 = cir.const(#cir.int<1> : !s32i) : !s32i
            cir.store %3, %2 : !s32i, cir.ptr <!s32i>
            cir.loop for(cond : {
              %4 = cir.load %2 : cir.ptr <!s32i>, !s32i
              %5 = cir.const(#cir.int<10> : !s32i) : !s32i
              %6 = cir.cmp(lt, %4, %5) : !s32i, !s32i
              %7 = cir.cast(int_to_bool, %6 : !s32i), !cir.bool
              cir.brcond %7 ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              cir.yield continue
            ^bb2:  // pred: ^bb0
              cir.yield
            }, step : {
              %4 = cir.load %2 : cir.ptr <!s32i>, !s32i
              %5 = cir.unary(inc, %4) : !s32i, !s32i
              cir.store %5, %2 : !s32i, cir.ptr <!s32i>
              cir.yield
            }) {
              cir.scope {
                cir.scope {
                  %4 = cir.load %2 : cir.ptr <!s32i>, !s32i
                  %5 = cir.const(#cir.int<5> : !s32i) : !s32i
                  %6 = cir.cmp(eq, %4, %5) : !s32i, !s32i
                  %7 = cir.cast(int_to_bool, %6 : !s32i), !cir.bool
                  cir.if %7 {
                    cir.yield break
                  }
                }
              }
              cir.yield
            }
          }
        }
        cir.yield
      }
    }
    cir.return
  }

// MLIR:           llvm.func @testForNested()
// MLIR-NEXT:        llvm.br ^bb1
// MLIR-NEXT:      ^bb1:  // pred: ^bb0
// MLIR-NEXT:        %0 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:        %1 = llvm.alloca %0 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr<i32>
// MLIR-NEXT:        %2 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        llvm.store %2, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb2
// ============= Condition block =============
// MLIR-NEXT:      ^bb2:  // 2 preds: ^bb1, ^bb22
// MLIR-NEXT:        %3 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %4 = llvm.mlir.constant(10 : i32) : i32
// MLIR-NEXT:        %5 = llvm.icmp "slt" %3, %4 : i32
// MLIR-NEXT:        %6 = llvm.zext %5 : i1 to i32
// MLIR-NEXT:        %7 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %8 = llvm.icmp "ne" %6, %7 : i32
// MLIR-NEXT:        %9 = llvm.zext %8 : i1 to i8
// MLIR-NEXT:        %10 = llvm.trunc %9 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %10, ^bb3, ^bb4
// MLIR-NEXT:      ^bb3:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb5
// MLIR-NEXT:      ^bb4:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb23
// MLIR-NEXT:      ^bb5:  // pred: ^bb3
// MLIR-NEXT:        llvm.br ^bb6
// MLIR-NEXT:      ^bb6:  // pred: ^bb5
// MLIR-NEXT:        llvm.br ^bb7
// ============= Nested loop =============
// MLIR-NEXT:      ^bb7:  // pred: ^bb6
// MLIR-NEXT:        %11 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:        %12 = llvm.alloca %11 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr<i32>
// MLIR-NEXT:        %13 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        llvm.store %13, %12 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb8
// ============= Condition block nested =============
// MLIR-NEXT:      ^bb8:  // 2 preds: ^bb7, ^bb18
// MLIR-NEXT:        %14 = llvm.load %12 : !llvm.ptr<i32>
// MLIR-NEXT:        %15 = llvm.mlir.constant(10 : i32) : i32
// MLIR-NEXT:        %16 = llvm.icmp "slt" %14, %15 : i32
// MLIR-NEXT:        %17 = llvm.zext %16 : i1 to i32
// MLIR-NEXT:        %18 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %19 = llvm.icmp "ne" %17, %18 : i32
// MLIR-NEXT:        %20 = llvm.zext %19 : i1 to i8
// MLIR-NEXT:        %21 = llvm.trunc %20 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %21, ^bb9, ^bb10
// MLIR-NEXT:      ^bb9:  // pred: ^bb8
// MLIR-NEXT:        llvm.br ^bb11
// MLIR-NEXT:      ^bb10:  // pred: ^bb8
// MLIR-NEXT:        llvm.br ^bb19
// MLIR-NEXT:      ^bb11:  // pred: ^bb9
// MLIR-NEXT:        llvm.br ^bb12
// MLIR-NEXT:      ^bb12:  // pred: ^bb11
// MLIR-NEXT:        llvm.br ^bb13
// ============= Block with break in nested loop =============
// MLIR-NEXT:      ^bb13:  // pred: ^bb12
// MLIR-NEXT:        %22 = llvm.load %12 : !llvm.ptr<i32>
// MLIR-NEXT:        %23 = llvm.mlir.constant(5 : i32) : i32
// MLIR-NEXT:        %24 = llvm.icmp "eq" %22, %23 : i32
// MLIR-NEXT:        %25 = llvm.zext %24 : i1 to i32
// MLIR-NEXT:        %26 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %27 = llvm.icmp "ne" %25, %26 : i32
// MLIR-NEXT:        %28 = llvm.zext %27 : i1 to i8
// MLIR-NEXT:        %29 = llvm.trunc %28 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %29, ^bb14, ^bb15
// MLIR-NEXT:      ^bb14:  // pred: ^bb13
// MLIR-NEXT:        llvm.br ^bb19
// MLIR-NEXT:      ^bb15:  // pred: ^bb13
// MLIR-NEXT:        llvm.br ^bb16
// MLIR-NEXT:      ^bb16:  // pred: ^bb15
// MLIR-NEXT:        llvm.br ^bb17
// MLIR-NEXT:      ^bb17:  // pred: ^bb16
// MLIR-NEXT:        llvm.br ^bb18
// ============= Body block in nested loop =============
// MLIR-NEXT:      ^bb18:  // pred: ^bb17
// MLIR-NEXT:        %30 = llvm.load %12 : !llvm.ptr<i32>
// MLIR-NEXT:        %31 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        %32 = llvm.add %30, %31  : i32
// MLIR-NEXT:        llvm.store %32, %12 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb8
// MLIR-NEXT:      ^bb19:  // 2 preds: ^bb10, ^bb14
// MLIR-NEXT:        llvm.br ^bb20
// MLIR-NEXT:      ^bb20:  // pred: ^bb19
// MLIR-NEXT:        llvm.br ^bb21
// ============= Exit block in nested loop =============
// MLIR-NEXT:      ^bb21:  // pred: ^bb20
// MLIR-NEXT:        llvm.br ^bb22
// ============= Body block =============
// MLIR-NEXT:      ^bb22:  // pred: ^bb21
// MLIR-NEXT:        %33 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %34 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        %35 = llvm.add %33, %34  : i32
// MLIR-NEXT:        llvm.store %35, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb2
// ============= Exit block =============
// MLIR-NEXT:      ^bb23:  // pred: ^bb4
// MLIR-NEXT:        llvm.br ^bb24
// MLIR-NEXT:      ^bb24:  // pred: ^bb23
// MLIR-NEXT:        llvm.return
// MLIR-NEXT:      }

  cir.func  @testWhile() {
    %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
    %1 = cir.const(#cir.int<0> : !s32i) : !s32i
    cir.store %1, %0 : !s32i, cir.ptr <!s32i>
    cir.scope {
      cir.loop while(cond : {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.const(#cir.int<10> : !s32i) : !s32i
        %4 = cir.cmp(lt, %2, %3) : !s32i, !s32i
        %5 = cir.cast(int_to_bool, %4 : !s32i), !cir.bool
        cir.brcond %5 ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        cir.yield continue
      ^bb2:  // pred: ^bb0
        cir.yield
      }, step : {
        cir.yield
      }) {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.unary(inc, %2) : !s32i, !s32i
        cir.store %3, %0 : !s32i, cir.ptr <!s32i>
        cir.scope {
          %4 = cir.load %0 : cir.ptr <!s32i>, !s32i
          %5 = cir.const(#cir.int<5> : !s32i) : !s32i
          %6 = cir.cmp(eq, %4, %5) : !s32i, !s32i
          %7 = cir.cast(int_to_bool, %6 : !s32i), !cir.bool
          cir.if %7 {
            cir.yield break
          }
        }
        cir.yield
      }
    }
    cir.return
  }

// MLIR:           llvm.func @testWhile()
// MLIR-NEXT:        %0 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:        %1 = llvm.alloca %0 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr<i32>
// MLIR-NEXT:        %2 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        llvm.store %2, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb1
// MLIR-NEXT:      ^bb1:  // pred: ^bb0
// MLIR-NEXT:        llvm.br ^bb2
// ============= Condition block =============
// MLIR-NEXT:      ^bb2:  // 2 preds: ^bb1, ^bb9
// MLIR-NEXT:        %3 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %4 = llvm.mlir.constant(10 : i32) : i32
// MLIR-NEXT:        %5 = llvm.icmp "slt" %3, %4 : i32
// MLIR-NEXT:        %6 = llvm.zext %5 : i1 to i32
// MLIR-NEXT:        %7 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %8 = llvm.icmp "ne" %6, %7 : i32
// MLIR-NEXT:        %9 = llvm.zext %8 : i1 to i8
// MLIR-NEXT:        %10 = llvm.trunc %9 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %10, ^bb3, ^bb4
// MLIR-NEXT:      ^bb3:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb5
// MLIR-NEXT:      ^bb4:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb10
// ============= Body block =============
// MLIR-NEXT:      ^bb5:  // pred: ^bb3
// MLIR-NEXT:        %11 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %12 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        %13 = llvm.add %11, %12  : i32
// MLIR-NEXT:        llvm.store %13, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb6
// ============= Block with break =============
// MLIR-NEXT:      ^bb6:  // pred: ^bb5
// MLIR-NEXT:        %14 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %15 = llvm.mlir.constant(5 : i32) : i32
// MLIR-NEXT:        %16 = llvm.icmp "eq" %14, %15 : i32
// MLIR-NEXT:        %17 = llvm.zext %16 : i1 to i32
// MLIR-NEXT:        %18 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %19 = llvm.icmp "ne" %17, %18 : i32
// MLIR-NEXT:        %20 = llvm.zext %19 : i1 to i8
// MLIR-NEXT:        %21 = llvm.trunc %20 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %21, ^bb7, ^bb8
// MLIR-NEXT:      ^bb7:  // pred: ^bb6
// MLIR-NEXT:        llvm.br ^bb10
// MLIR-NEXT:      ^bb8:  // pred: ^bb6
// MLIR-NEXT:        llvm.br ^bb9
// MLIR-NEXT:      ^bb9:  // pred: ^bb8
// MLIR-NEXT:        llvm.br ^bb2
// MLIR-NEXT:      ^bb10:  // 2 preds: ^bb4, ^bb7
// MLIR-NEXT:        llvm.br ^bb11
// ============= Exit block =============
// MLIR-NEXT:      ^bb11:  // pred: ^bb10
// MLIR-NEXT:        llvm.return
// MLIR-NEXT:      }

cir.func @testDoWhile() {
    %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
    %1 = cir.const(#cir.int<0> : !s32i) : !s32i
    cir.store %1, %0 : !s32i, cir.ptr <!s32i>
    cir.scope {
      cir.loop dowhile(cond : {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.const(#cir.int<10> : !s32i) : !s32i
        %4 = cir.cmp(lt, %2, %3) : !s32i, !s32i
        %5 = cir.cast(int_to_bool, %4 : !s32i), !cir.bool
        cir.brcond %5 ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        cir.yield continue
      ^bb2:  // pred: ^bb0
        cir.yield
      }, step : {
        cir.yield
      }) {
        %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
        %3 = cir.unary(inc, %2) : !s32i, !s32i
        cir.store %3, %0 : !s32i, cir.ptr <!s32i>
        cir.scope {
          %4 = cir.load %0 : cir.ptr <!s32i>, !s32i
          %5 = cir.const(#cir.int<5> : !s32i) : !s32i
          %6 = cir.cmp(eq, %4, %5) : !s32i, !s32i
          %7 = cir.cast(int_to_bool, %6 : !s32i), !cir.bool
          cir.if %7 {
            cir.yield break
          }
        }
        cir.yield
      }
    }
    cir.return
  }

// MLIR:          llvm.func @testDoWhile()
// MLIR-NEXT:        %0 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:        %1 = llvm.alloca %0 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr<i32>
// MLIR-NEXT:        %2 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        llvm.store %2, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb1
// MLIR-NEXT:      ^bb1:  // pred: ^bb0
// MLIR-NEXT:        llvm.br ^bb5
// ============= Condition block =============
// MLIR-NEXT:      ^bb2:  // pred: ^bb9
// MLIR-NEXT:        %3 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %4 = llvm.mlir.constant(10 : i32) : i32
// MLIR-NEXT:        %5 = llvm.icmp "slt" %3, %4 : i32
// MLIR-NEXT:        %6 = llvm.zext %5 : i1 to i32
// MLIR-NEXT:        %7 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %8 = llvm.icmp "ne" %6, %7 : i32
// MLIR-NEXT:        %9 = llvm.zext %8 : i1 to i8
// MLIR-NEXT:        %10 = llvm.trunc %9 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %10, ^bb3, ^bb4
// MLIR-NEXT:      ^bb3:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb5
// MLIR-NEXT:      ^bb4:  // pred: ^bb2
// MLIR-NEXT:        llvm.br ^bb10
// ============= Body block =============
// MLIR-NEXT:      ^bb5:  // 2 preds: ^bb1, ^bb3
// MLIR-NEXT:        %11 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %12 = llvm.mlir.constant(1 : i32) : i32
// MLIR-NEXT:        %13 = llvm.add %11, %12  : i32
// MLIR-NEXT:        llvm.store %13, %1 : !llvm.ptr<i32>
// MLIR-NEXT:        llvm.br ^bb6
// ============= Block with break =============
// MLIR-NEXT:      ^bb6:  // pred: ^bb5
// MLIR-NEXT:        %14 = llvm.load %1 : !llvm.ptr<i32>
// MLIR-NEXT:        %15 = llvm.mlir.constant(5 : i32) : i32
// MLIR-NEXT:        %16 = llvm.icmp "eq" %14, %15 : i32
// MLIR-NEXT:        %17 = llvm.zext %16 : i1 to i32
// MLIR-NEXT:        %18 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:        %19 = llvm.icmp "ne" %17, %18 : i32
// MLIR-NEXT:        %20 = llvm.zext %19 : i1 to i8
// MLIR-NEXT:        %21 = llvm.trunc %20 : i8 to i1
// MLIR-NEXT:        llvm.cond_br %21, ^bb7, ^bb8
// MLIR-NEXT:      ^bb7:  // pred: ^bb6
// MLIR-NEXT:        llvm.br ^bb10
// MLIR-NEXT:      ^bb8:  // pred: ^bb6
// MLIR-NEXT:        llvm.br ^bb9
// MLIR-NEXT:      ^bb9:  // pred: ^bb8
// MLIR-NEXT:        llvm.br ^bb2
// ============= Exit block =============
// MLIR-NEXT:      ^bb10:  // 2 preds: ^bb4, ^bb7
// MLIR-NEXT:        llvm.br ^bb11
// MLIR-NEXT:      ^bb11:  // pred: ^bb10
// MLIR-NEXT:        llvm.return
// MLIR-NEXT:      }

}